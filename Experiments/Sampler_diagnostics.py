import autograd.numpy as np
import matplotlib.pyplot as plt
from statsmodels.graphics.tsaplots import plot_acf
from scipy.stats import ttest_ind
import pandas as pd



# Get a way of checking the acceptance rate of the NUTS sampler
# Traceplots
def traceplot(traces):
    print('The traceplots are useful in order to visualize the burn-in and the mixing of the MCMC chain')
    w_0 = traces[0]
    w_1 = traces[1]
    w_2 = traces[2]
    fig, ax = plt.subplots(3, 1, figsize=(18, 30))
    ax[0].plot(range(len(w_0)), w_0, color='b')
    ax[1].plot(range(len(w_1)), w_1, color='r')
    ax[2].plot(range(len(w_2)), w_2, color='y')
    plt.show(fig)


def acf_plot(traces, lag, number_param):
    print('The autocorrelation plots are useful in order to determine the amount of thinning you wish to perform in your chain')
    plot_acf(traces[number_param], lags=lag, label='For the weight ' + str(number_param))


def Gelman_Rubin(traces):
    """
     Quantity which compares the empirical variance of all the chains pooled and the average empirical variance within each chain. If it
        is large then the chains are very different (not converged). 1 ideal but in practice we accept < 1.05.
    :param traces: the traceplots generated by our sampler. Needs to have several different chains ran from different starting points
    :return: Gelman_Rubin coefficient
    """
    W = 0
    B = 0
    theta_overall_mean = np.mean(traces)  # mean over all the axes
    for trace in traces:  # iterate over the different chains
        sigma_m = np.mean((trace-np.mean(trace))**2)
        mean_m = np.mean(trace)
        B += (theta_overall_mean-mean_m)**2
        W += sigma_m
    return B/W


def Geweke(traces):
    """
    takes two nonoverlapping parts (usually the first 0.1 and last 0.5 proportions) of the Markov chain and compares the
    means of both parts, using a difference of means test to see if the two parts of the chain are from the same distribution
    (the test statistic is a standard Z-score with the standard errors adjusted for autocorrelation).
    You should reject the test if p > 0.05 and accept equal means
    :param traces:
    :return: Geweke Z score test
    """
    sample1 = traces[:, :0.1*traces.shape[1]]
    sample2 = traces[:, 0.5*traces.shape[1]:]
    results_tests = []
    for i in range(traces.shape[0]):
        results_tests.append(list(ttest_ind(sample1[i], sample2[i])))
    results_tests_df = pd.DataFrame(np.array(results_tests).T, columns=['t-statistic', 'p-value'])
    return results_tests

